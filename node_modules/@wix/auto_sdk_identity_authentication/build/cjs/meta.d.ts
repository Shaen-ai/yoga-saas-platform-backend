import { RegisterV2Request as RegisterV2Request$1, StateMachineResponse as StateMachineResponse$1, LoginV2Request as LoginV2Request$1, ChangePasswordRequest as ChangePasswordRequest$1, ChangePasswordResponse as ChangePasswordResponse$1, SignOnRequest as SignOnRequest$1, SignOnResponse as SignOnResponse$1, LogoutRequest as LogoutRequest$1, RawHttpResponse as RawHttpResponse$1, VerifyRequest as VerifyRequest$1 } from './index.typings.js';
import '@wix/sdk-types';

interface Authentication {
}
interface RegisterV2Request {
    /** Identifier of the registering member. */
    loginId: LoginId;
    /** Password of the registering member. */
    password?: string;
    /** Profile information of registering member. */
    profile?: IdentityProfile;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data that's relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface LoginId extends LoginIdTypeOneOf {
    /**
     * Login email address.
     * @format EMAIL
     */
    email?: string;
}
/** @oneof */
interface LoginIdTypeOneOf {
    /**
     * Login email address.
     * @format EMAIL
     */
    email?: string;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /**
     * List of profile labels.
     * @maxSize 2000
     */
    labels?: string[];
    /**
     * Profile language.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatusWithLiterals;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /**
     * Company name.
     * @maxLength 1000
     */
    company?: string | null;
    /**
     * Position within company.
     * @maxLength 1000
     */
    position?: string | null;
    /**
     * Profile birthdate in `YYYY-MM-DD` format.
     * @format LOCAL_DATE
     */
    birthdate?: string | null;
    /**
     * Profile slug.
     * @maxLength 255
     */
    slug?: string | null;
    /** Consent to be added to mailing list */
    subscription?: boolean | null;
    /**
     * Government id for personal/corporate (Vat ID).
     * @maxLength 1000
     */
    vatId?: string | null;
}
declare enum PrivacyStatus {
    /** No defined privacy status. */
    UNDEFINED = "UNDEFINED",
    /** Profile details, such as profile name and profile picture, are visible to other members. */
    PUBLIC = "PUBLIC",
    /** Profile details aren't visible to other members. */
    PRIVATE = "PRIVATE"
}
/** @enumType */
type PrivacyStatusWithLiterals = PrivacyStatus | 'UNDEFINED' | 'PUBLIC' | 'PRIVATE';
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /**
     * Email address.
     * @format EMAIL
     */
    email?: string;
    /** Email tag. */
    tag?: EmailTagWithLiterals;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
/** @enumType */
type EmailTagWithLiterals = EmailTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'WORK';
interface Phone {
    /**
     * Phone country code.
     * @format COUNTRY
     */
    countryCode?: string | null;
    /**
     * Phone number.
     * @format PHONE
     */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTagWithLiterals;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
/** @enumType */
type PhoneTagWithLiterals = PhoneTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'MOBILE' | 'WORK' | 'FAX';
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTagWithLiterals;
}
/** Physical address */
interface Address {
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine?: string | null;
    /** Free text providing more detailed address info. Usually contains apartment, suite, and floor. */
    addressLine2?: string | null;
    /**
     * Street name.
     * @maxLength 1000
     */
    streetName?: string | null;
    /**
     * Street number.
     * @maxLength 1000
     */
    streetNumber?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
/** @enumType */
type AddressTagWithLiterals = AddressTag | 'UNTAGGED' | 'HOME' | 'WORK' | 'BILLING' | 'SHIPPING';
interface CaptchaToken extends CaptchaTokenTokenOneOf {
    /** @maxLength 5000 */
    Recaptcha?: string;
    /** @maxLength 5000 */
    InvisibleRecaptcha?: string;
    /** @maxLength 5000 */
    NoCaptcha?: string;
}
/** @oneof */
interface CaptchaTokenTokenOneOf {
    /** @maxLength 5000 */
    Recaptcha?: string;
    /** @maxLength 5000 */
    InvisibleRecaptcha?: string;
    /** @maxLength 5000 */
    NoCaptcha?: string;
}
interface StateMachineResponse extends StateMachineResponseStateDataOneOf {
    /** Current state of the login or registration process. */
    state?: StateTypeWithLiterals;
    /** Session token. If `state` is not `SUCCESS`, this field is undefined. */
    sessionToken?: string | null;
    /** Token that represents the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identity of the current member. */
    identity?: Identity;
    /** Additional data relevant to the login or registration process. */
    additionalData?: Record<string, CustomValue>;
}
/** @oneof */
interface StateMachineResponseStateDataOneOf {
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** Login completed successfully. */
    SUCCESS = "SUCCESS",
    /** Indicates that the member needs the owner to approve their registration. */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /** Indicates that the member needs to verify their email. */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** Indicates that the `status` is not one that prevents the member logging in, meaning it's not `OFFLINE`, `BLOCKED`, or `DELETED`. */
    STATUS_CHECK = "STATUS_CHECK"
}
/** @enumType */
type StateTypeWithLiterals = StateType | 'UNKNOWN_STATE' | 'SUCCESS' | 'REQUIRE_OWNER_APPROVAL' | 'REQUIRE_EMAIL_VERIFICATION' | 'STATUS_CHECK';
interface Identity {
    /**
     * Identity ID.
     * @format GUID
     */
    id?: string | null;
    /**
     * Revision number, which increments by 1 each time the identity is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the identity.
     *
     * Ignored when creating an identity.
     */
    revision?: string | null;
    /**
     * Date and time the identity was created.
     * @readonly
     */
    createdDate?: Date | null;
    /**
     * Date and time the identity was updated.
     * @readonly
     */
    updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** Custom attributes. */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity verification factors.
     * @maxSize 10
     * @readonly
     */
    factors?: Factor[];
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /**
     * IDP connection ID.
     * @format GUID
     */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /**
     * Authenticator connection ID.
     * @format GUID
     */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface Metadata {
}
interface Email {
    /**
     * Email address.
     * @format EMAIL
     */
    address?: string;
    /** Whether the email address is verified. */
    isVerified?: boolean;
}
interface StatusV2 {
    /** Descriptive name of the identity status. */
    name?: StatusNameWithLiterals;
    /** Reasons for the current identity status. */
    reasons?: ReasonWithLiterals[];
}
declare enum StatusName {
    /** Unknown status. This value isn't used. */
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Identity is pending verification, owner approval, or both. */
    PENDING = "PENDING",
    /** Identity is active and can log in. */
    ACTIVE = "ACTIVE",
    /** Identity is deleted. This identity can't log in. */
    DELETED = "DELETED",
    /** Identity is blocked. This identity can't log in. */
    BLOCKED = "BLOCKED",
    /** Identity is offline. This identity can't log in. */
    OFFLINE = "OFFLINE"
}
/** @enumType */
type StatusNameWithLiterals = StatusName | 'UNKNOWN_STATUS' | 'PENDING' | 'ACTIVE' | 'DELETED' | 'BLOCKED' | 'OFFLINE';
declare enum Reason {
    /** Unknown reason. This value isn't used. */
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** The identity is waiting for admin approval. After the approval, the identity has an `ACTIVE` status. */
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    /** The identity has to verify the email. After the verification, the identity has an `ACTIVE` status. */
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'PENDING_ADMIN_APPROVAL_REQUIRED' | 'PENDING_EMAIL_VERIFICATION_REQUIRED';
interface Factor {
    /**
     * Factor ID.
     * @format GUID
     */
    factorId?: string;
    /** Factor type. */
    type?: FactorTypeWithLiterals;
    /** Factor status. */
    status?: StatusWithLiterals;
}
declare enum FactorType {
    /** Unknown factor type. */
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    /** Requires a password. */
    PASSWORD = "PASSWORD",
    /** Requires a code sent via SMS. */
    SMS = "SMS",
    /** Requires a code sent by phone call. */
    CALL = "CALL",
    /** Requires a code sent by email. */
    EMAIL = "EMAIL",
    /** Requires authentication via an authenticator app. */
    TOTP = "TOTP",
    /** Requires authentication via a push notification. */
    PUSH = "PUSH",
    /** Requires authentication via WebAuthn/passkey. */
    WEBAUTHN = "WEBAUTHN",
    /** Requires a recovery code. */
    RECOVERY_CODE = "RECOVERY_CODE"
}
/** @enumType */
type FactorTypeWithLiterals = FactorType | 'UNKNOWN_FACTOR_TYPE' | 'PASSWORD' | 'SMS' | 'CALL' | 'EMAIL' | 'TOTP' | 'PUSH' | 'WEBAUTHN' | 'RECOVERY_CODE';
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
/** @enumType */
type StatusWithLiterals = Status | 'INACTIVE' | 'ACTIVE' | 'REQUIRE_REENROLL';
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface RequireMfaData {
    /**
     * The factors available for the user to perform the required MFA.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
interface V1Factor {
    /** Type of verification factor. */
    factorType?: FactorTypeWithLiterals;
    /** Availability status for second factor */
    factorStatus?: FactorStatusWithLiterals;
}
declare enum FactorStatus {
    UNKNOWN_FACTOR_STATUS = "UNKNOWN_FACTOR_STATUS",
    ENABLED = "ENABLED",
    REQUIRE_ACTIVATION = "REQUIRE_ACTIVATION",
    REQUIRE_REENROLL = "REQUIRE_REENROLL",
    ENABLED_BY_RULE = "ENABLED_BY_RULE",
    DISABLED_BY_RULE = "DISABLED_BY_RULE"
}
/** @enumType */
type FactorStatusWithLiterals = FactorStatus | 'UNKNOWN_FACTOR_STATUS' | 'ENABLED' | 'REQUIRE_ACTIVATION' | 'REQUIRE_REENROLL' | 'ENABLED_BY_RULE' | 'DISABLED_BY_RULE';
declare enum MfaReason {
    UNKNOWN_MFA_REASON = "UNKNOWN_MFA_REASON",
    /** Mfa is required due to user settings */
    USER_SETTINGS = "USER_SETTINGS",
    /** Mfa is required due to high risk login */
    HIGH_RISK_LOGIN = "HIGH_RISK_LOGIN"
}
/** @enumType */
type MfaReasonWithLiterals = MfaReason | 'UNKNOWN_MFA_REASON' | 'USER_SETTINGS' | 'HIGH_RISK_LOGIN';
interface MfaChallengeData {
    /** Type of verifation factor. */
    factorType?: FactorTypeWithLiterals;
    verificationChallengeData?: VerificationChallenge;
    /**
     * Factors types the user can choose from to verify themselves.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required for verification. */
    reason?: MfaReasonWithLiterals;
}
interface VerificationChallenge extends VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
    /** @maxLength 200 */
    hint?: string | null;
}
/** @oneof */
interface VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
}
interface PushChallengeData {
    /**
     * This should be tied to a specific push notification.
     * It will be sent in subsequent requests to verify the factor.
     * @maxLength 36
     */
    transactionId?: string;
}
interface WebAuthnChallengeData {
    /**
     * A unique identifier for this challenge that will be used to correlate
     * the authentication response with this challenge.
     * This should be a cryptographically random GUID to prevent guessing attacks.
     * @format GUID
     */
    challengeId?: string;
    /**
     * The challenge that will be signed by the authenticator during the WebAuthn authentication ceremony.
     * This should be a cryptographically secure random value with at least 16 bytes of entropy.
     * The value is used to prevent replay attacks and MUST be randomly generated by the implementer.
     */
    challenge?: Uint8Array;
    /**
     * The timeout in milliseconds for the WebAuthn authentication ceremony.
     * After this time, the challenge will be considered expired and the authentication will need to be restarted.
     * This is optional and may be overridden by the client if provided.
     * The WebAuthn spec recommends a timeout of at least 1 minute (60000ms).
     */
    timeoutMs?: number | null;
    /**
     * Optional list of credentials that are acceptable for this authentication ceremony.
     * If empty, all credentials associated with the user will be considered.
     * @maxSize 50
     */
    allowCredentials?: PublicKeyCredentialDescriptor[];
    /** Specifies the requirement for user verification during the authentication ceremony. */
    userVerification?: UserVerificationRequirementWithLiterals;
    /**
     * Optional hints to guide the client UI
     * Examples include "security-key" to emphasize external authenticators
     * or "client-device" to emphasize built-in authenticators
     * @maxLength 50
     * @maxSize 10
     */
    hints?: string[];
    /**
     * Optional extensions for the authentication ceremony
     * Provides additional parameters for specialized WebAuthn functionality
     */
    extensions?: AuthenticationExtensionInputs;
}
interface PublicKeyCredentialDescriptor {
    /** The credential ID */
    id?: Uint8Array;
    /**
     * An optional hint as to the transports used by the credential
     * Examples include "usb", "nfc", "ble", "internal", "hybrid"
     * @maxLength 50
     * @maxSize 10
     */
    transports?: string[];
}
declare enum UserVerificationRequirement {
    /** Default unspecified value */
    USER_VERIFICATION_UNSPECIFIED = "USER_VERIFICATION_UNSPECIFIED",
    /**
     * The Relying Party requires user verification and will fail the operation if the response doesn't have the UV flag
     * set
     */
    USER_VERIFICATION_REQUIRED = "USER_VERIFICATION_REQUIRED",
    /** The Relying Party prefers user verification but will not fail the operation if unavailable */
    USER_VERIFICATION_PREFERRED = "USER_VERIFICATION_PREFERRED",
    /** The Relying Party does not want user verification employed (e.g., to minimize disruption to the user experience) */
    USER_VERIFICATION_DISCOURAGED = "USER_VERIFICATION_DISCOURAGED"
}
/** @enumType */
type UserVerificationRequirementWithLiterals = UserVerificationRequirement | 'USER_VERIFICATION_UNSPECIFIED' | 'USER_VERIFICATION_REQUIRED' | 'USER_VERIFICATION_PREFERRED' | 'USER_VERIFICATION_DISCOURAGED';
interface AuthenticationExtensionInputs extends AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
    /**
     * FIDO AppID Extension (appid)
     * An AppID that was used for previously registered U2F authenticators
     * This makes already-registered U2F credentials forward-compatible with the WebAuthn API
     * @maxLength 256
     */
    appid?: string;
    /**
     * User Verification Method Extension (uvm)
     * Requests the authenticator to report which verification methods were used
     * Examples include fingerprint, PIN, or facial recognition
     */
    uvm?: boolean;
}
/** @oneof */
interface AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
}
interface LoginV2Request {
    /** Identifier of identity logging in. */
    loginId: LoginId;
    /** Password of the identity logging in. */
    password?: string | null;
    /** CAPTCHA tokens, when CAPTCHA setting is on. */
    captchaTokens?: CaptchaToken[];
    /** Additional data that's relevant for the flow. */
    clientMetaData?: Record<string, any> | null;
}
interface WebAuthnVerifyData {
    /**
     * The challenge_id from the WebAuthnChallengeData that was returned in the previous
     * verification response. This will always be present when completing the WebAuthn authentication
     * ceremony with the credential data from the client.
     * @format GUID
     */
    challengeId?: string | null;
    /**
     * If this field is present, this is a request to complete the WebAuthn authentication
     * with the credential data from the client.
     *
     * The credential contains a JSON string representation of a WebAuthn PublicKeyCredential
     * object returned by the browser during authentication, serialized as per the WebAuthn specification.
     * The SPI implementation should use this to verify the authentication assertion.
     *
     * Any standards-compliant WebAuthn server library should be able to process this serialized format.
     * For details on the serialization format, refer to the W3C WebAuthn specification:
     * https://www.w3.org/TR/webauthn-3/#dom-publickeycredential-tojson
     * @maxLength 3000
     */
    credential?: string | null;
}
interface ExternalEmailVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
interface ChangePasswordRequest {
    /** The new password to set for the logged in user */
    newPassword: string;
}
interface ChangePasswordResponse {
}
interface LoginWithIdpConnectionRequest {
    /**
     * The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData
     * @format GUID
     */
    idpConnectionId?: string;
    /**
     * The id of the tenant the caller wants to login into
     * @format GUID
     */
    tenantId?: string;
    /** The type of the tenant the caller wants to login into */
    tenantType?: TenantTypeWithLiterals;
    customPayload?: Record<string, string>;
    /**
     * This flow ultimately returns an HTML page that asynchronously posts the LoginResponse via the BroadcastChannel API.
     * The message will be posted to a channel named `wix-idp-$session_id`, and encrypted with the `encryption_key`.
     * Encryption key should be base64 encoded. Encryption is done using AES-GCM with a random IV that's sent alongside the payload
     */
    sessionId?: string;
    encryptionKey?: string;
    visitorId?: string | null;
    bsi?: string | null;
}
declare enum TenantType {
    /** Unknown tenant type. This value isn't used. */
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    /** The identity is a Wix user. */
    ACCOUNT = "ACCOUNT",
    /** The identity is a member. */
    SITE = "SITE"
}
/** @enumType */
type TenantTypeWithLiterals = TenantType | 'UNKNOWN_TENANT_TYPE' | 'ACCOUNT' | 'SITE';
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry {
    key?: string;
    value?: string;
}
interface QueryParametersEntry {
    key?: string;
    value?: string;
}
interface LoginCallbackRequest {
    /** state that that received on the redirect */
    state?: string;
    /** session token */
    sessionToken?: string;
}
interface LoginWithIdpConnectionTokenParamsRequest {
    /**
     * The id of the connection id (can be fetched by calling connection-service.listEnabledConnectionsClientData)
     * @format GUID
     */
    idpConnectionId?: string;
    /** A set of fields that are required for the connection to be able to identify and authenticate the user */
    tokenParams?: Record<string, string>;
}
interface SignOnRequest {
    /** the identifier of the identity */
    loginId: LoginId;
    /** profile of the identity */
    profile?: IdentityProfile;
    /** when true will mark the email of the identity as verified */
    verifyEmail?: boolean;
    /** when false will create a new contact instead of merging the existing contact into the identity */
    mergeExistingContact?: boolean;
}
interface SignOnResponse {
    /** session token for the requested identity */
    sessionToken?: string;
    /** The Identity of the provided login_id */
    identity?: Identity;
}
/** logout request payload */
interface LogoutRequest {
    /**
     * redirect after logout
     * @format WEB_URL
     */
    postLogoutRedirectUri?: string | null;
    /**
     * caller identifier
     * @format GUID
     */
    clientId?: string | null;
}
interface VerifyRequest extends VerifyRequestFactorDataOneOf {
    smsData?: SmsVerifyData;
    callData?: CallVerifyData;
    emailData?: ExternalEmailVerifyData;
    totpData?: TotpVerifyData;
    pushData?: PushVerifyData;
    webauthnData?: WebAuthnVerifyData;
    /**
     * TODO: is this a reasonable maxLength?
     * @maxLength 1000
     */
    stateToken?: string;
    factorType: FactorTypeWithLiterals;
    /** Relevant for second factors only. */
    rememberThisDevice?: boolean;
}
/** @oneof */
interface VerifyRequestFactorDataOneOf {
    smsData?: SmsVerifyData;
    callData?: CallVerifyData;
    emailData?: ExternalEmailVerifyData;
    totpData?: TotpVerifyData;
    pushData?: PushVerifyData;
    webauthnData?: WebAuthnVerifyData;
}
interface SmsVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
interface CallVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
interface TotpVerifyData {
    /**
     * @minLength 1
     * @maxLength 100
     */
    code?: string | null;
}
interface PushVerifyData {
    /** @maxLength 36 */
    transactionId?: string | null;
}
interface GetWebauthnChallengeRequest {
    /**
     * Identifier of identity for which the WebAuthn challenge is requested for.
     * If not provided an anonymous webAuthn challenge will be returned.
     */
    loginId?: LoginId;
}
interface GetWebauthnChallengeResponse {
    /** The challenge that will be used for a WebAuthn authentication ceremony. */
    webauthn?: WebAuthnChallengeData;
}
/** @docsIgnore */
type RegisterV2ApplicationErrors = {
    code?: 'UNIMPLEMENTED_FEATURE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'THROTTLED_FEATURE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_CAPTCHA_TOKEN';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CAPTCHA_TOKEN_REQUIRED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'IP_ADDRESS_FILTERED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECAPTCHA_FAILED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'RECAPTCHA_REQUIRED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'MISSING_CAPTCHA_TOKEN';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'USER_EMAIL_OFAC_ADDRESS';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'UNSUPPORTED_FIELD';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'ATTRIBUTE_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CLIENT_METADATA_NOT_FOUND';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_LD_SESSION';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'DUPLICATE_EMAIL';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'COULD_NOT_CREATE_SET_ACCOUNT_USER';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_USER_TYPE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'REGISTRATION_TO_EDITORX_NOT_ALLOWED';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type RegisterV2ValidationErrors = {
    ruleName?: 'PROVIDE_TENANT_ID';
} | {
    ruleName?: 'INVALID_AUTHENTICATOR_ID';
} | {
    ruleName?: 'VALUEֹֹ_TOO_SHORT';
} | {
    ruleName?: 'VALUEֹֹ_TOO_LONG';
} | {
    ruleName?: 'VALUE_DID_NOT_MATCH';
};
/** @docsIgnore */
type LoginV2ApplicationErrors = {
    code?: 'THROTTLED_FEATURE';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'INVALID_CAPTCHA_TOKEN';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'CAPTCHA_TOKEN_REQUIRED';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'REENROLLMENT_REQUIRED_BY_ADMIN';
    description?: string;
    data?: Record<string, any>;
} | {
    code?: 'TRUSTED_CLIENTS_ONLY';
    description?: string;
    data?: Record<string, any>;
};
/** @docsIgnore */
type LoginV2ValidationErrors = {
    ruleName?: 'PROVIDE_TENANT_ID';
} | {
    ruleName?: 'INVALID_AUTHENTICATOR_ID';
};

type __PublicMethodMetaInfo<K = string, M = unknown, T = unknown, S = unknown, Q = unknown, R = unknown> = {
    getUrl: (context: any) => string;
    httpMethod: K;
    path: string;
    pathParams: M;
    __requestType: T;
    __originalRequestType: S;
    __responseType: Q;
    __originalResponseType: R;
};
declare function registerV2(): __PublicMethodMetaInfo<'POST', {}, RegisterV2Request$1, RegisterV2Request, StateMachineResponse$1, StateMachineResponse>;
declare function loginV2(): __PublicMethodMetaInfo<'POST', {}, LoginV2Request$1, LoginV2Request, StateMachineResponse$1, StateMachineResponse>;
declare function changePassword(): __PublicMethodMetaInfo<'POST', {}, ChangePasswordRequest$1, ChangePasswordRequest, ChangePasswordResponse$1, ChangePasswordResponse>;
declare function signOn(): __PublicMethodMetaInfo<'POST', {}, SignOnRequest$1, SignOnRequest, SignOnResponse$1, SignOnResponse>;
declare function logout(): __PublicMethodMetaInfo<'GET', {}, LogoutRequest$1, LogoutRequest, RawHttpResponse$1, RawHttpResponse>;
declare function verify(): __PublicMethodMetaInfo<'POST', {
    factorType: string;
}, VerifyRequest$1, VerifyRequest, StateMachineResponse$1, StateMachineResponse>;

export { type Address as AddressOriginal, AddressTag as AddressTagOriginal, type AddressTagWithLiterals as AddressTagWithLiteralsOriginal, type AddressWrapper as AddressWrapperOriginal, type AuthenticationExtensionInputsLargeBlobOperationOneOf as AuthenticationExtensionInputsLargeBlobOperationOneOfOriginal, type AuthenticationExtensionInputs as AuthenticationExtensionInputsOriginal, type Authentication as AuthenticationOriginal, type AuthenticatorConnection as AuthenticatorConnectionOriginal, type CallVerifyData as CallVerifyDataOriginal, type CaptchaToken as CaptchaTokenOriginal, type CaptchaTokenTokenOneOf as CaptchaTokenTokenOneOfOriginal, type ChangePasswordRequest as ChangePasswordRequestOriginal, type ChangePasswordResponse as ChangePasswordResponseOriginal, type Connection as ConnectionOriginal, type ConnectionTypeOneOf as ConnectionTypeOneOfOriginal, type CustomField as CustomFieldOriginal, type CustomValue as CustomValueOriginal, type CustomValueValueOneOf as CustomValueValueOneOfOriginal, type Email as EmailOriginal, EmailTag as EmailTagOriginal, type EmailTagWithLiterals as EmailTagWithLiteralsOriginal, type ExternalEmailVerifyData as ExternalEmailVerifyDataOriginal, type Factor as FactorOriginal, FactorStatus as FactorStatusOriginal, type FactorStatusWithLiterals as FactorStatusWithLiteralsOriginal, FactorType as FactorTypeOriginal, type FactorTypeWithLiterals as FactorTypeWithLiteralsOriginal, type GetWebauthnChallengeRequest as GetWebauthnChallengeRequestOriginal, type GetWebauthnChallengeResponse as GetWebauthnChallengeResponseOriginal, type HeadersEntry as HeadersEntryOriginal, type Identity as IdentityOriginal, type IdentityProfile as IdentityProfileOriginal, type IdpConnection as IdpConnectionOriginal, type ListValue as ListValueOriginal, type LoginCallbackRequest as LoginCallbackRequestOriginal, type LoginId as LoginIdOriginal, type LoginIdTypeOneOf as LoginIdTypeOneOfOriginal, type LoginV2ApplicationErrors as LoginV2ApplicationErrorsOriginal, type LoginV2Request as LoginV2RequestOriginal, type LoginV2ValidationErrors as LoginV2ValidationErrorsOriginal, type LoginWithIdpConnectionRequest as LoginWithIdpConnectionRequestOriginal, type LoginWithIdpConnectionTokenParamsRequest as LoginWithIdpConnectionTokenParamsRequestOriginal, type LogoutRequest as LogoutRequestOriginal, type MapValue as MapValueOriginal, type Metadata as MetadataOriginal, type MfaChallengeData as MfaChallengeDataOriginal, MfaReason as MfaReasonOriginal, type MfaReasonWithLiterals as MfaReasonWithLiteralsOriginal, type PathParametersEntry as PathParametersEntryOriginal, type Phone as PhoneOriginal, PhoneTag as PhoneTagOriginal, type PhoneTagWithLiterals as PhoneTagWithLiteralsOriginal, PrivacyStatus as PrivacyStatusOriginal, type PrivacyStatusWithLiterals as PrivacyStatusWithLiteralsOriginal, type PublicKeyCredentialDescriptor as PublicKeyCredentialDescriptorOriginal, type PushChallengeData as PushChallengeDataOriginal, type PushVerifyData as PushVerifyDataOriginal, type QueryParametersEntry as QueryParametersEntryOriginal, type RawHttpRequest as RawHttpRequestOriginal, type RawHttpResponse as RawHttpResponseOriginal, Reason as ReasonOriginal, type ReasonWithLiterals as ReasonWithLiteralsOriginal, type RegisterV2ApplicationErrors as RegisterV2ApplicationErrorsOriginal, type RegisterV2Request as RegisterV2RequestOriginal, type RegisterV2ValidationErrors as RegisterV2ValidationErrorsOriginal, type RequireMfaData as RequireMfaDataOriginal, type SecondaryEmail as SecondaryEmailOriginal, type SignOnRequest as SignOnRequestOriginal, type SignOnResponse as SignOnResponseOriginal, type SmsVerifyData as SmsVerifyDataOriginal, type StateMachineResponse as StateMachineResponseOriginal, type StateMachineResponseStateDataOneOf as StateMachineResponseStateDataOneOfOriginal, StateType as StateTypeOriginal, type StateTypeWithLiterals as StateTypeWithLiteralsOriginal, StatusName as StatusNameOriginal, type StatusNameWithLiterals as StatusNameWithLiteralsOriginal, Status as StatusOriginal, type StatusV2 as StatusV2Original, type StatusWithLiterals as StatusWithLiteralsOriginal, TenantType as TenantTypeOriginal, type TenantTypeWithLiterals as TenantTypeWithLiteralsOriginal, type TotpVerifyData as TotpVerifyDataOriginal, UserVerificationRequirement as UserVerificationRequirementOriginal, type UserVerificationRequirementWithLiterals as UserVerificationRequirementWithLiteralsOriginal, type V1CustomValue as V1CustomValueOriginal, type V1CustomValueValueOneOf as V1CustomValueValueOneOfOriginal, type V1Factor as V1FactorOriginal, type V1ListValue as V1ListValueOriginal, type V1MapValue as V1MapValueOriginal, type VerificationChallengeFactorChallengeDataOneOf as VerificationChallengeFactorChallengeDataOneOfOriginal, type VerificationChallenge as VerificationChallengeOriginal, type VerifyRequestFactorDataOneOf as VerifyRequestFactorDataOneOfOriginal, type VerifyRequest as VerifyRequestOriginal, type WebAuthnChallengeData as WebAuthnChallengeDataOriginal, type WebAuthnVerifyData as WebAuthnVerifyDataOriginal, type __PublicMethodMetaInfo, changePassword, loginV2, logout, registerV2, signOn, verify };
